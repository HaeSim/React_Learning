useState 를 통해 컴포넌트에서 바뀌는 값 관리하기

> ## Q. 함수형 업데이트?
>
> - ### setState()는 비동기적으로 작동한다
>
>   ```javascript
>   export default function App() {
>     const [value, setValue] = useState(0);
>
>     const onClick = () => {
>       setValue(value + 1);
>       setValue(value + 1);
>       setValue(value + 1);
>     };
>
>     return (
>       <div className='App'>
>         <button onClick={onClick}>+</button>
>         <h1>{value}</h1>
>       </div>
>     );
>   }
>   ```
>
>   - 위 코드를 보면 클릭 이벤트가 발생하면 초기값 0에서 3이 될 것 같지만, 실제로는 1이 된다. 왜냐하면 비동기 처리가 되기 때문에 최종적으로 초기 상태값인 0에서 +1되는 `setState()`만 발생하기 때문.
>   - 리액트는 렌더링을 효율적으로 하기 위해, 동시에 여러 개의 상태값 변경요청이 들어오면, batch(일괄처리) 처리한다.
>   - `setState()`가 발생한다는 것은 곧 리렌더링의 기준이 되는 State의 변화가 일어난다는 것이고, `setState()`마다 자원을 많이 소모하는 리렌더링이 일어난다는 의미가 된다!!
>   - 그렇기 때문에 리액트에서는 `setState()`를 비동기로 일괄 처리하는 것이다.
>
> - ### 동기적으로 처리하고 싶다면 어떻게 하면 될까?
>   - `setState()`시에 새로운 변경값을 넣어주는 것이 아니라, 콜백함수를 넣어주면 된다.
>   - 이때, 콜백함수는 `prevState => prevState 어쩌고저쩌고` 형태의 이전 상태값을 활용한 컨벤션으로 작성 가능하다.
>   - 그렇게 되면 `setState()`가 실행될 때 마다, 변경된 state를 참조하여 업데이트가 되기 때문에 동기적으로 처리가 된다.
>   - 함수형 업데이트를 `useCallback()` 과 함께 사용하게 되면 컴포넌트 리렌더링 성능 최적화에 큰 도움이 된다. (함수도 재생성 안되고, deps값을 넣을 필요가 없기 때문에)
> - ### 참조
>   - [React DOC](https://ko.reactjs.org/docs/faq-state.html)
>   - [syteibne Velog](https://velog.io/@suyeonme/react-useState%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81-%EC%86%8D%EC%84%B1-%ED%95%A8%EC%88%98%ED%98%95-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8)
